<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache-BeanUtils</title>
    <url>/2021/05/02/Apache-BeanUtils/</url>
    <content><![CDATA[<p>简介：Apache BeanUtil提供了很多的基于类、属性、方法之间的获取和设置的方式</p>
<img src="/2021/05/02/Apache-BeanUtils/propertyUtil.png" style="zoom: 50%;">

<a id="more"></a>

<h2 id="PropertyUtils"><a href="#PropertyUtils" class="headerlink" title="PropertyUtils"></a>PropertyUtils</h2><p><strong><em>本质上是调用PropertyUtilsBean类来实现功能</em></strong></p>
<ol>
<li><p>访问基本数据类型的Bean属性</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getSimpleProperty-java.lang.Object-java.lang.String-">PropertyUtils.getSimpleProperty(Object, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setSimpleProperty-java.lang.Object-java.lang.String-java.lang.Object-">PropertyUtils.setSimpleProperty(Object, String, Object)</a></li>
</ul>
<p>示例：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">String firstName = (String) PropertyUtils.getSimpleProperty(employee, <span class="string">&quot;firstName&quot;</span>);   <span class="comment">// 获取基本类型属性的值</span></span><br><span class="line">String lastName = (String) PropertyUtils.getSimpleProperty(employee, <span class="string">&quot;lastName&quot;</span>);</span><br><span class="line"></span><br><span class="line">PropertyUtils.setSimpleProperty(employee, <span class="string">&quot;firstName&quot;</span>, firstName);                    <span class="comment">// 设置基本类型的属性值</span></span><br><span class="line">PropertyUtils.setSimpleProperty(employee, <span class="string">&quot;lastName&quot;</span>, lastName);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>访问索引类型的Bean属性</li>
</ol>
<p>获取bean中含有可索引的属性，如果ArrayList、数组等，可以通过下标索引来访问Bean属性的值，同理也可以设置值</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getIndexedProperty-java.lang.Object-java.lang.String-">PropertyUtils.getIndexedProperty(Object, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getIndexedProperty-java.lang.Object-java.lang.String-int-">PropertyUtils.getIndexedProperty(Object, String, int)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setIndexedProperty-java.lang.Object-java.lang.String-java.lang.Object-">PropertyUtils.setIndexedProperty(Object, String, Object)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setIndexedProperty-java.lang.Object-java.lang.String-int-java.lang.Object-">PropertyUtils.setIndexedProperty(Object, String, int, Object)</a></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee employee00 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,<span class="string">&quot;employeeList&quot;</span>, <span class="number">0</span>);  <span class="comment">// 获取indexBean中employeeList中的index=0的元素</span></span><br><span class="line">Employee employee11 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,<span class="string">&quot;employeeList&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>访问Map映射类型的Bean属性</li>
</ol>
<p>获取bean中含有常见的HashMap，TreeMap等，可以通过key来访问Bean属性值，同理可设置value</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getMappedProperty-java.lang.Object-java.lang.String-">PropertyUtils.getMappedProperty(Object, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getMappedProperty-java.lang.Object-java.lang.String-java.lang.String-">PropertyUtils.getMappedProperty(Object, String, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setMappedProperty-java.lang.Object-java.lang.String-java.lang.Object-">PropertyUtils.setMappedProperty(Object, String, Object)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setMappedProperty-java.lang.Object-java.lang.String-java.lang.String-java.lang.Object-">PropertyUtils.setMappedProperty(Object, String, String, Object)</a></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyUtils.setMappedProperty(employee, <span class="string">&quot;mapProperty&quot;</span>, <span class="string">&quot;testKey1&quot;</span>, <span class="string">&quot;testValue1&quot;</span>);</span><br><span class="line">PropertyUtils.setMappedProperty(employee, <span class="string">&quot;mapProperty(testKey2)&quot;</span>, <span class="string">&quot;testValue2&quot;</span>);</span><br></pre></td></tr></table></figure>

<pre><code>4. 访问嵌套类型的Bean属性</code></pre>
<p>获取bean中含有指的是对象内嵌套对象</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getNestedProperty-java.lang.Object-java.lang.String-">PropertyUtils.getNestedProperty(Object, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setNestedProperty-java.lang.Object-java.lang.String-java.lang.Object-">PropertyUtils.setNestedProperty(Object, String, Object)</a></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lastName = (String) PropertyUtils.getNestedProperty(nestedBean,<span class="string">&quot;mapProperty(testKey).lastName&quot;</span>);</span><br><span class="line">String lastName2 = (String) PropertyUtils.getNestedProperty(nestedBean,<span class="string">&quot;listProperty[0].lastName&quot;</span>);</span><br></pre></td></tr></table></figure>

<pre><code>5. 访问所有类型的Bean属性</code></pre>
<p>通过以上API的使用，我们了解了各类bean属性的访问方法，其实还有一种通用的方法，适用于各类bean属性类型</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#getProperty-java.lang.Object-java.lang.String-">PropertyUtils.getProperty(Object, String)</a></li>
<li><a href="http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setProperty-java.lang.Object-java.lang.String-java.lang.Object-">PropertyUtils.setProperty(Object, String, Object)</a></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyUtils.setProperty(nestedBean, <span class="string">&quot;listProperty[0].lastName&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>PropertyUtils依赖于PropertyBeanUtils，其中PropertyBeanUtils中使用到了java.beans包下的 <code>PropertyDescriptor</code></p>
<h2 id="DynaClass-amp-DynaBean"><a href="#DynaClass-amp-DynaBean" class="headerlink" title="DynaClass &amp; DynaBean"></a>DynaClass &amp; DynaBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义动态属性和类型</span></span><br><span class="line">DynaProperty[] props = <span class="keyword">new</span> DynaProperty[]&#123;</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;address&quot;</span>, java.util.Map.class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;subordinate&quot;</span>, mypackage.Employee[].class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;firstName&quot;</span>, String.class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;lastName&quot;</span>,  String.class)</span><br><span class="line">          &#125;;</span><br><span class="line"><span class="comment">// 定义动态类，并注入动态属性</span></span><br><span class="line">BasicDynaClass dynaClass = <span class="keyword">new</span> BasicDynaClass(<span class="string">&quot;employee&quot;</span>, <span class="keyword">null</span>, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态类实例出动态实例对象</span></span><br><span class="line">DynaBean employee = dynaClass.newInstance();</span><br><span class="line"><span class="comment">// 动态实例设置属性值</span></span><br><span class="line">employee.set(<span class="string">&quot;address&quot;</span>, <span class="keyword">new</span> HashMap());</span><br><span class="line">employee.set(<span class="string">&quot;subordinate&quot;</span>, <span class="keyword">new</span> Employee[]&#123;...&#125;);</span><br><span class="line">employee.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">employee.set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Flintstone&quot;</span>);</span><br><span class="line"><span class="comment">// 获取动态属性值</span></span><br><span class="line">String firstName = (String) employee.get(<span class="string">&quot;firstName&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Class 对象 —&gt; class.newInstance 通过类对象实例化一个实例对象<br>constructor 对象 —&gt; constructor.newInstance 同样是实例化一个对象</p>
<h2 id="BasicDynaBean和BasicDynaClass"><a href="#BasicDynaBean和BasicDynaClass" class="headerlink" title="BasicDynaBean和BasicDynaClass"></a>BasicDynaBean和BasicDynaClass</h2><p>先了解下这两个重要的实现，这两个类为DynaBean和DynaClass接口的基础实现类</p>
<p>首先，我们可以这样创建一个<code>DynaClass</code>实例，其中类的成员属性是用<code>DynaProperty</code>类来描述的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DynaProperty[] props = <span class="keyword">new</span> DynaProperty[]</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;address&quot;</span>, java.util.Map.class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;subordinate&quot;</span>, Employee[].class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;firstName&quot;</span>, String.class),</span><br><span class="line">            <span class="keyword">new</span> DynaProperty(<span class="string">&quot;lastName&quot;</span>, String.class) </span><br><span class="line">        &#125;;</span><br><span class="line">BasicDynaClass dynaClass = <span class="keyword">new</span> BasicDynaClass(<span class="string">&quot;employee&quot;</span>, <span class="keyword">null</span>, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的Class&lt;?&gt; **dynaBeanClass** 参数为空，看下源码就发现，如果为null的话，默认会使用 BasicDynaBean.class；</span></span><br><span class="line"><span class="comment">// 在BasicDyaBean 中保存了一个Hash&lt;String,Object&gt; 用于保存字段名和字段值</span></span><br></pre></td></tr></table></figure>

<h2 id="ResultSetDynaClass"><a href="#ResultSetDynaClass" class="headerlink" title="ResultSetDynaClass"></a>ResultSetDynaClass</h2><p><code>ResultSetDynaClass</code> 继承于 <code>JDBCDynaClass</code> 来处理JDBC的ResultSet结果集，而<code>JDBCDynaClass</code>实现了<code>DynaClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, address, state FROM user&quot;</span>;</span><br><span class="line">stmt = conn.prepareStatement(sql);</span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">// **将 ResultSet 结果集包装为 ResultSetDynaClass 类型**</span></span><br><span class="line">Iterator&lt;DynaBean&gt; rows = (<span class="keyword">new</span> ResultSetDynaClass(rs)).iterator();</span><br><span class="line"><span class="keyword">while</span> (rows.hasNext()) &#123;</span><br><span class="line">    DynaBean row = rows.next();</span><br><span class="line">    System.out.print(<span class="string">&quot;id: &quot;</span> + row.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;, name: &quot;</span> + row.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;, address: &quot;</span> + row.get(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;, state: &quot;</span> + row.get(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultSetDynaClass作为SQL查询结果集中的一个动态bean非常实用，但是仍然有一个严重的缺陷，就是使用ResultSetDynaClass的前提是要保证ResultSet一直处于打开状态，这对于分层结构的Web项目来说是非常不便的，因为我们经常需要将数据从dao层传到service层传到view层，而ResultSet在DAO层使用后往往会关闭掉；</p>
<p>为解决这个问题，引入了RowSetDynaClass实现类，与ResultSetDynaClass不同的是，它会自己在内存中拷贝一份数据，这样就保证了即使ResultSet关闭后，数据也能一直被访问到；不过同样也有缺点就是需要消耗性能用于拷贝数据以及占用堆内存空间；</p>
<h2 id="RowSetDynaClass"><a href="#RowSetDynaClass" class="headerlink" title="RowSetDynaClass"></a>RowSetDynaClass</h2><p><code>RowSetDynaClass</code> 继承于 <code>JDBCDynaClass</code> 来处理JDBC的ResultSet结果集，而<code>JDBCDynaClass</code>实现了<code>DynaClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;SELECT id, name, address, state FROM user&quot;</span>;</span><br><span class="line">stmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果集进行包装</span></span><br><span class="line">RowSetDynaClass rowSet = <span class="keyword">new</span> RowSetDynaClass(rs);</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line"></span><br><span class="line">List&lt;DynaBean&gt; rowlist = rowSet.getRows();</span><br><span class="line"><span class="keyword">for</span> (DynaBean row : rowlist) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;id: &quot;</span> + row.get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;, name: &quot;</span> + row.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.print(<span class="string">&quot;, address: &quot;</span> + row.get(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;, state: &quot;</span> + row.get(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WrapDynaBean和WrapDynaClass"><a href="#WrapDynaBean和WrapDynaClass" class="headerlink" title="WrapDynaBean和WrapDynaClass"></a>WrapDynaBean和WrapDynaClass</h2><p>使用<code>WrapDynaBean</code>，我们可以将普通的<code>javabean</code>包装成<code>DynaBean</code>，并非常简便的使用DynaBean提供的API方法来访问bean成员属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.setFirstName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">DynaBean wrapper = <span class="keyword">new</span> WrapDynaBean(e);</span><br><span class="line">String firstName = (String) wrapper.get(<span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">System.out.println(firstName);</span><br></pre></td></tr></table></figure>

<h2 id="Lazy-DynaBeans"><a href="#Lazy-DynaBeans" class="headerlink" title="Lazy DynaBeans"></a>Lazy DynaBeans</h2><p>Lazy DynaBeans有如下特性：</p>
<p>1、自动添加bean属性，当我们调用<code>set(name, value)方法时，如果属性不存在，会自动添加该属性；</code></p>
<p>2、List、Array属性自动扩容，</p>
<p>3、List、Array属性里的内部元素可以自动创建，实例化</p>
<p>4、Map属性也可以自动创建，实例化</p>
<p>简单的说，使用Lazy DynaBeans的话，你可以大胆调用DynaBean的set、get方法，而不必担心没有属性不存在，集合数组空间不够等问题，Lazy DynaBeans会帮我们自动处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DynaBean dynaBean = <span class="keyword">new</span> LazyDynaBean();</span><br><span class="line"></span><br><span class="line">dynaBean.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);                   <span class="comment">// simple</span></span><br><span class="line"></span><br><span class="line">dynaBean.set(<span class="string">&quot;customer&quot;</span>, <span class="string">&quot;title&quot;</span>, <span class="string">&quot;Mr&quot;</span>);      <span class="comment">// mapped</span></span><br><span class="line">dynaBean.set(<span class="string">&quot;customer&quot;</span>, <span class="string">&quot;surname&quot;</span>, <span class="string">&quot;Smith&quot;</span>); <span class="comment">// mapped</span></span><br><span class="line"></span><br><span class="line">dynaBean.set(<span class="string">&quot;users&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> User());     <span class="comment">// indexed</span></span><br><span class="line">dynaBean.set(<span class="string">&quot;users&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> User());     <span class="comment">// indexed</span></span><br><span class="line">dynaBean.set(<span class="string">&quot;users&quot;</span>, <span class="number">2</span>, <span class="keyword">new</span> User());     <span class="comment">// indexed</span></span><br><span class="line"></span><br><span class="line">System.out.println(dynaBean.get(<span class="string">&quot;customer&quot;</span>, <span class="string">&quot;title&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="BeanComparator"><a href="#BeanComparator" class="headerlink" title="BeanComparator"></a>BeanComparator</h2><p>用于两个Bean之间指定字段的比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义需要比较的字段</span></span><br><span class="line"><span class="keyword">final</span> BeanComparator&lt;AlphaBean, String&gt; beanComparator = <span class="keyword">new</span> BeanComparator&lt;&gt;(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 两个bean之间进行比较 ，注意，**bean1和bean2 都不能为null**</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> result = beanComparator.compare(alphaBean1, alphaBean2);</span><br></pre></td></tr></table></figure>

<h2 id="BeanMap"><a href="#BeanMap" class="headerlink" title="BeanMap"></a>BeanMap</h2><p>基于java.beans包下的 <code>Introspector</code>  内省来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanMap beanMap = <span class="keyword">new</span> BeanMap(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见方法</span></span><br><span class="line">org.apache.commons.beanutils2.BeanMap#containsKey(final Object name)    // 判断bean中是否有name属性</span><br><span class="line">org.apache.commons.beanutils2.BeanMap#containsValue(final Object value) // 判断bean中是否有value属性值</span><br><span class="line">org.apache.commons.beanutils2.BeanMap#get(final Object name)            // 获取bean中name属性的值</span><br><span class="line">org.apache.commons.beanutils2.BeanMap#put(final String name, final Object value) // 设置属性和属性值</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理分析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> HashMap&lt;String, Method&gt; readMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> HashMap&lt;String, Method&gt; writeMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> HashMap&lt;String, Class&lt;? extends Object&gt;&gt; types = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanMap中会有三个Map分别用于保存字段的 setXX、getXX、字段类型的方法</span></span><br></pre></td></tr></table></figure>

<h2 id="BeanPredicate"><a href="#BeanPredicate" class="headerlink" title="BeanPredicate"></a>BeanPredicate</h2><p>用于比较bean中字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义比较断言</span></span><br><span class="line"><span class="keyword">final</span> Predicate&lt;String&gt; p = s -&gt; s.equals(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// 2.定义BeanPredicate断言，并指定比较**字段名**</span></span><br><span class="line"><span class="keyword">final</span> BeanPredicate&lt;String&gt; predicate = <span class="keyword">new</span> BeanPredicate&lt;&gt;(<span class="string">&quot;stringProperty&quot;</span>, p);</span><br><span class="line"><span class="comment">// 3.进行比较</span></span><br><span class="line">predicate.test(<span class="keyword">new</span> TestBean(<span class="string">&quot;foo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="BeanPropertyValueChangeConsumer"><a href="#BeanPropertyValueChangeConsumer" class="headerlink" title="BeanPropertyValueChangeConsumer"></a>BeanPropertyValueChangeConsumer</h2><p>用于bean进行设置属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义要设置的字段和字段值</span></span><br><span class="line">BeanPropertyValueChangeConsumer consumer = <span class="keyword">new</span> BeanPropertyValueChangeConsumer&lt;&gt;(<span class="string">&quot;floatProperty&quot;</span>, expectedFloatValue)</span><br><span class="line"><span class="comment">// 2.进行设置 --&gt; PropertyUtils.setProperty(object, propertyName, propertyValue);</span></span><br><span class="line">consumer.accept(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于数组的设置</span></span><br><span class="line"><span class="keyword">new</span> BeanPropertyValueChangeConsumer&lt;&gt;(<span class="string">&quot;intIndexed[0]&quot;</span>, expectedIntegerValue).accept(testBean);</span><br><span class="line"><span class="comment">// 基于map的设置</span></span><br><span class="line"><span class="keyword">new</span> BeanPropertyValueChangeConsumer&lt;&gt;(<span class="string">&quot;mappedProperty(fred)&quot;</span>, <span class="string">&quot;barney&quot;</span>).accept(testBean);</span><br><span class="line"><span class="comment">// 基于内嵌对象的设置</span></span><br><span class="line"><span class="keyword">new</span> BeanPropertyValueChangeConsumer&lt;&gt;(<span class="string">&quot;nested.stringProperty&quot;</span>, <span class="string">&quot;bar&quot;</span>).accept(testBean);</span><br></pre></td></tr></table></figure>

<h2 id="BeanPropertyValueEqualsPredicate"><a href="#BeanPropertyValueEqualsPredicate" class="headerlink" title="BeanPropertyValueEqualsPredicate"></a>BeanPropertyValueEqualsPredicate</h2><p>用于bean的属性值之间的比较，但与<code>BeanPredicate</code> 的区别是<code>BeanPropertyValueEqualsPredicate</code> 的比较是使用<code>Object.equal</code> 方法，没有<code>BeanPredicate</code> 的灵活</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义属性和属性值</span></span><br><span class="line">BeanPropertyValueEqualsPredicate&lt;TestBean, String&gt; predicate = <span class="keyword">new</span> BeanPropertyValueEqualsPredicate&lt;&gt;(<span class="string">&quot;stringProperty&quot;</span>,<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// 2.进行比较</span></span><br><span class="line">predicate.test(<span class="keyword">new</span> TestBean(<span class="string">&quot;foo&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于数组比较</span></span><br><span class="line">BeanPropertyValueEqualsPredicate&lt;TestBean, Object&gt; predicate = <span class="keyword">new</span> BeanPropertyValueEqualsPredicate&lt;&gt;(<span class="string">&quot;intIndexed[0]&quot;</span>,expectedIntegerValue);</span><br><span class="line">predicate.test(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于map比较</span></span><br><span class="line">BeanPropertyValueEqualsPredicate&lt;TestBean, String&gt; predicate = <span class="keyword">new</span> BeanPropertyValueEqualsPredicate&lt;&gt;(<span class="string">&quot;mappedProperty(key)&quot;</span>, <span class="string">&quot;match&quot;</span>);</span><br><span class="line">predicate.test(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于内嵌对象比较</span></span><br><span class="line">BeanPropertyValueEqualsPredicate&lt;TestBean, String&gt; predicate = <span class="keyword">new</span> BeanPropertyValueEqualsPredicate&lt;&gt;(<span class="string">&quot;anotherNested.stringProperty&quot;</span>,<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">predicate.test(testBean)</span><br></pre></td></tr></table></figure>

<h2 id="BeanToPropertyValueTransformer"><a href="#BeanToPropertyValueTransformer" class="headerlink" title="BeanToPropertyValueTransformer"></a>BeanToPropertyValueTransformer</h2><p>用于获取bean的属性对应的属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义属性</span></span><br><span class="line">BeanToPropertyValueTransformer&lt;TestBean, String&gt; transformer = <span class="keyword">new</span> BeanToPropertyValueTransformer&lt;&gt;(<span class="string">&quot;stringProperty&quot;</span>);</span><br><span class="line"><span class="comment">// 2.获取属性值</span></span><br><span class="line">TestBean testBean = <span class="keyword">new</span> TestBean(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">transformer.apply(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组</span></span><br><span class="line">BeanToPropertyValueTransformer&lt;TestBean, Integer&gt; transformer = <span class="keyword">new</span> BeanToPropertyValueTransformer&lt;&gt;(<span class="string">&quot;intIndexed[0]&quot;</span>)</span><br><span class="line">transformer.apply(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取map</span></span><br><span class="line">BeanToPropertyValueTransformer&lt;TestBean, String&gt; transformer = <span class="keyword">new</span> BeanToPropertyValueTransformer&lt;&gt;(<span class="string">&quot;mappedProperty(key)&quot;</span>)</span><br><span class="line">transformer.apply(testBean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内嵌对象</span></span><br><span class="line">BeanToPropertyValueTransformer&lt;TestBean, String&gt; transformer = <span class="keyword">new</span> BeanToPropertyValueTransformer&lt;&gt;(<span class="string">&quot;anotherNested.stringProperty&quot;</span>)</span><br><span class="line">transformer.apply(testBean)</span><br></pre></td></tr></table></figure>

<h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>用于对bean中的属性进行解析，可以识别数组、map、内嵌对象。默认的实现是<code>DefaultResolver</code>  其中 <code>PropertyUtilsBean</code> 就是通过这个类来解析bean的属性表达式的</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内嵌对象的识别  --&gt; name1.name2.name3</span></span><br><span class="line"><span class="comment">// 数组的识别     --&gt; name[index]</span></span><br><span class="line"><span class="comment">// map的识别     --&gt; name(key)</span></span><br><span class="line"></span><br><span class="line">Resolver resolver = <span class="keyword">new</span> DefaultResolver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见方法</span></span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#getIndex      // 获取指定索引下的值</span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#getKey        // 获取map下的key</span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#getProperty   // 获取属性</span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#hasNested     // 判断是否是内嵌对象</span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#isIndexed     // 判断是否是数组</span><br><span class="line">org.apache.commons.beanutils2.expression.DefaultResolver#isMapped      // 判断是否是map</span><br></pre></td></tr></table></figure>

<h2 id="BeanUtils和BeanUtilsBean"><a href="#BeanUtils和BeanUtilsBean" class="headerlink" title="BeanUtils和BeanUtilsBean"></a>BeanUtils和BeanUtilsBean</h2><p>BeanUtils中都是静态的方法，每个方法都是调用BeanUtilsBean中的方法并且BeanUtilsBean中定义为单例模式</p>
<p>BeanUtilsBean的单例模式是通过 (thread) context Classloader 来实现的<br>BeanUtilBean是依赖于 <code>ConvertUtilsBean</code> 和 <code>PropertyUtilsBean</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见方法</span></span><br><span class="line">org.apache.commons.beanutils2.BeanUtilsBean#cloneBean       // 克隆一个新Bean</span><br><span class="line">org.apache.commons.beanutils2.BeanUtilsBean#copyProperties  // 源目对象复制</span><br><span class="line">org.apache.commons.beanutils2.BeanUtilsBean#copyProperty    // 仅复制对象的某个属性</span><br><span class="line">org.apache.commons.beanutils2.BeanUtilsBean#describe        // 将bean转换为一个Map&lt;属性名,属性值&gt;</span><br><span class="line">org.apache.commons.beanutils2.BeanUtilsBean#populate        // 填充bean</span><br></pre></td></tr></table></figure>

<h2 id="ConstructorUtils"><a href="#ConstructorUtils" class="headerlink" title="ConstructorUtils"></a>ConstructorUtils</h2><p>用于类对象利用反射方式实例化一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object obj = ConstructorUtils.invokeConstructor(TestBean.class,<span class="string">&quot;TEST&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ConvertUtils和ConvertUtilsBean"><a href="#ConvertUtils和ConvertUtilsBean" class="headerlink" title="ConvertUtils和ConvertUtilsBean"></a>ConvertUtils和ConvertUtilsBean</h2><p>用于数据类型之间的转换，<code>ConvertUtilsBean</code>的构造方法中 <code>deregister()</code>  方法会加载<code>**88**</code>个默认的类型转换器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字符串数组转换为包装类型的数组</span></span><br><span class="line"><span class="keyword">final</span> String[] values1 = &#123; <span class="string">&quot;10&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;30&quot;</span> &#125;;</span><br><span class="line">Object value = ConvertUtils.convert(values1, Integer.TYPE);    <span class="comment">// &#123;10,20,30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.包装类型转换为字符串数组类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] intArray1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Object value = ConvertUtils.convert(intArray1, String[].class);  <span class="comment">// String[] 看做是一个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.字符串转换为时间类型</span></span><br><span class="line">String input = <span class="string">&quot;2002-03-17&quot;</span>;</span><br><span class="line">Object value = ConvertUtils.convert(input, Date.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.自定义转换类型</span></span><br><span class="line"><span class="keyword">final</span> ConvertUtilsBean utils = <span class="keyword">new</span> ConvertUtilsBean();</span><br><span class="line">utils.register(dateConverter, java.util.Date.class);</span><br><span class="line">utils.convert(today, String.class)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理：ConvertUtilBean中有一个WeakFastHashMap对象用于保存数据类型和之间的转换映射关系</span></span><br></pre></td></tr></table></figure>

<h2 id="MethodUtils"><a href="#MethodUtils" class="headerlink" title="MethodUtils"></a>MethodUtils</h2><p>用于进行method的反射调用，MethodUtils中有一个<code>WeakHashMap</code> 类型的map来保存method的缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Method method = MethodUtils.getAccessibleMethod(TestBean.class, <span class="string">&quot;setStringProperty&quot;</span>, String.class);</span><br><span class="line"><span class="keyword">final</span> Object result = MethodUtils.invokeExactMethod(</span><br><span class="line">                <span class="keyword">new</span> AlphaBean(<span class="string">&quot;parent&quot;</span>),</span><br><span class="line">                <span class="string">&quot;getName&quot;</span>,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="WeakFastHashMap"><a href="#WeakFastHashMap" class="headerlink" title="WeakFastHashMap"></a>WeakFastHashMap</h2><p>类似于 <code>CopyOnWriteArrayList</code> 的机制，其中通过fast字段来判断是否加锁，在读操作的时候不加锁，写操作的时候加锁</p>
]]></content>
      <categories>
        <category>apache-common</category>
      </categories>
      <tags>
        <tag>apache-common-beanutils</tag>
      </tags>
  </entry>
</search>
